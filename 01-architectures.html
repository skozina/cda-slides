<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <title>Binary Code Analysis - Agenda</title>
  <meta name="copyright"
   content="Copyright &#169; 2016 Stanislav Kozina <skozina@redhat.com>" />
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
   href="styles/slidy.css" />
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
   href="styles/w3c-blue.css" />
  <script src="scripts/slidy.js" charset="utf-8"
   type="text/javascript"></script>
  <link rel="stylesheet" type="text/css" href="styles/cda.css" />
</head>

<body>

<div class="background">
  <img id="head-icon" alt="graphic with four colored squares" src="images/bca.png" />
  <img src="images/Logo_RH_RGB_Default.png" alt="RH logo" id="head-logo" />
</div>

<div class="slide cover">
 <div>
 <img src="images/Logo_RH_RGB_Default.png" alt="RH logo" class="cover" />
 <br clear="all" />
 <h1>Binary Code Analysis</h1>
 <h2>Computer Architectures</h2>
 <p>Stanislav Kozina<br>
 Associate Manager, Software Engineering, Red Hat<br>
 &copy; January 2016</p>
 </div>
</div>

<div class="slide">
	<h1>Agenda</h1>
	<ul>
		<li>Computer architectures in general</li>
		<li>Registers</li>
		<li>The x86 and x86_64 computer architectures, common instructions</li>
		<li>Implicit and explicit stack operations</li>
		<li>System V ABI on x86_64 architecture</li>
	</ul>
</div>

<div class="slide">
	<h1>Agenda</h1>
	<ul>
		<li>Computer architectures in general</li>
		<li>Registers</li>
		<li><span class="red">The x86 and x86_64 computer architectures</span>, common instructions</li>
		<li>Implicit and explicit stack operations</li>
		<li>System V ABI on x86_64 architecture</span></li>
	</ul>
</div>

<div class="slide">
	<h1>History</h1>
	<ul>
		<li>1978: Intel 8086, 16bit, 20bit addressing, only real mode</li>
		<li>1982: Intel 80286, 16bit, 24bit addressing, Protected
			mode, MMU (Paging!)</li>
		<li>1985: Intel 80386, 32bit, known as IA32 (x86)</li>
		<li>2003: AMD Athlon 64, 64bit, 40bit addressing, known as AMD64 (x86_64)</li>
			<ul>
				<li>Do <em>NOT</em> confuse with IA64!</li>
				<li>That's Intel Itanium</li>
			</ul>
		<li>Today: Intel Kaby Lake, 64bit, 46bit addressing</li>
	</ul>
	<img alt="Seattle Computer" src="images/Seattle_Computer_8086-2.jpg"/>
	<p class="grey">Source: http://www.s100computers.com</p>
</div>

<div class="slide">
	<h1>Features</h1>
	<ul>
		<li>FPU, MMX, PAE, SSE, SMP, VT-x, GPU, TSX, &hellip;</li>
		<li>Full backwards compatibility</li>
		<ul>
			<li>Except for segmentation changes, mandatory paging
				etc.</li>
		</ul>
		<li>Little endian</li>
		<li>Variable instruction length</li>
		<li>CISC</li>
		<ul>
			<li>Many, many instructions, often similar</li>
			<li>Src/Dst operands can be in memory</li>
			<li>RISC micro-instructions in the core anyway</li>
		</ul>
	</ul>
</div>

<div class="slide">
<h1>Variable instruction size</h1>
<pre>
(gdb) disassemble /r pthread_create
Dump of assembler code for function pthread_create@@GLIBC_2.2.5:
   55			push   %rbp
   48 89 e5		mov    %rsp,%rbp
   41 57		push   %r15
   41 56		push   %r14
   41 55		push   %r13
   41 54		push   %r12
   49 89 f4		mov    %rsi,%r12
   53			push   %rbx
   48 81 ec b8 00 00 00	sub    $0xb8,%rsp
   48 85 f6		test   %rsi,%rsi
   48 89 bd 50 ff ff ff	mov    %rdi,-0xb0(%rbp)
   48 89 b5 48 ff ff ff	mov    %rsi,-0xb8(%rbp)
   48 89 95 60 ff ff ff	mov    %rdx,-0xa0(%rbp)
   48 89 8d 58 ff ff ff	mov    %rcx,-0xa8(%rbp)
   c6 85 6f ff ff ff 00	movb   $0x0,-0x91(%rbp)
</pre>
</div>

<div class="slide">
	<h1>Little Endian</h1>
	<ul>
		<li>The way the CPU accesses <em>multi-byte</em> content.</li>
		<li>Makes difference in communication between different
			platforms</li>
		<ul>
			<li>RPC, Network byte ordering, DMA</li>
		</ul>
	</ul>
	<pre>
int a = 0x12345678;
</pre>
	<pre>
(gdb) x/4xb &a
0x60102c &lt;a&gt;:	0x78	0x56	0x34	0x12
</pre>
</div>

<div class="slide">
	<h1>32-bit General Purpose Registers (GPR)</h1>
	<ul>
		<li>Overlapping access to the single register</li>
		<li>Based on access width (8/16/32 bits)</li>
	</ul>
	<table>
		<tr>
			<td>32</td>
			<td>24</td>
			<td>16</td>
			<td>8</td>
		</tr>
		<tr class="border">
			<td colspan=4>%e&#x2731;x</td>
		</tr>
		<tr class="border">
			<td colspan=2 class="dark" style="width=50%;"></td>
			<td colspan=2>%&#x2731;x</td>
		</tr>
		<tr class="border">
			<td colspan=2 class="dark" style="width=50%;"></td>
			<td>%&#x2731;h</td>
			<td>%&#x2731;l</td>
		</tr>
	</table>
	<p>&#x2731; is one of [abcd]</p>
	<table>
		<tr>
			<td>32</td>
			<td>24</td>
			<td>16</td>
			<td>8</td>
		</tr>
		<tr class="border">
			<td colspan=4>%e&#x2731;</td>
		</tr>
		<tr class="border">
			<td colspan=2 class="dark" style="width=50%;"></td>
			<td colspan=2>%&#x2731;</td>
		</tr>
	</table>
	<p>&#x2731; is one of [di|si|bp|sp]</p>
</div>

<div class="slide">
	<h1>64-bit General Purpose Registers (GPR)</h1>
	<table>
		<tr>
			<td>64</td>
			<td>56</td>
			<td>48</td>
			<td>40</td>
			<td>32</td>
			<td>24</td>
			<td>16</td>
			<td>8</td>
		</tr>
		<tr class="border">
			<td colspan=8>%r&#x2731;x</td>
		</tr>
		<tr class="border">
			<td colspan=4 class="dark" style="width=50%;"></td>
			<td colspan=4>%e&#x2731;x</td>
		</tr>
		<tr class="border">
			<td colspan=6 class="dark" style="width=50%;"></td>
			<td colspan=2>%&#x2731;x</td>
		</tr>
		<tr class="border">
			<td colspan=6 class="dark" style="width=50%;"></td>
			<td class="dark">%&#x2731;h</td>
			<td>%&#x2731;l</td>
		</tr>
	</table>
	<p>&#x2731; is one of [abcd]; The %&#x2731;h are deprecated</p>
	<table>
		<tr>
			<td>64</td>
			<td>56</td>
			<td>48</td>
			<td>40</td>
			<td>32</td>
			<td>24</td>
			<td>16</td>
			<td>8</td>
		</tr>
		<tr class="border">
			<td colspan=8>%r&#x2731;</td>
		</tr>
		<tr class="border">
			<td colspan=4 class="dark" style="width=50%;"></td>
			<td colspan=4>%e&#x2731;</td>
		</tr>
		<tr class="border">
			<td colspan=6 class="dark" style="width=50%;"></td>
			<td colspan=2>%&#x2731;</td>
		</tr>
		<tr class="border">
			<td colspan=7 class="dark" style="width=50%;"></td>
			<td>%&#x2731;l</td>
		</tr>
	</table>
	<p>&#x2731; is one of [di|si|bp|sp]</p>
	<p>Also, %rip / %eip / %ip pointing to the <em>next</em> instruction to
	execute is available for reading</p>
</div>

<div class="slide">
	<h1>64-bit General Purpose Registers (GPR) cont.</h1>
	<table>
		<tr>
			<td>64</td>
			<td>56</td>
			<td>48</td>
			<td>40</td>
			<td>32</td>
			<td>24</td>
			<td>16</td>
			<td>8</td>
		</tr>
		<tr class="border">
			<td colspan=8>%r&#x2731;</td>
		</tr>
		<tr class="border">
			<td colspan=4 class="dark" style="width=50%;"></td>
			<td colspan=4>%r&#x2731;d</td>
		</tr>
		<tr class="border">
			<td colspan=6 class="dark" style="width=50%;"></td>
			<td colspan=2>%r&#x2731;w</td>
		</tr>
		<tr class="border">
			<td colspan=7 class="dark" style="width=50%;"></td>
			<td>r%&#x2731;b</td>
		</tr>
	</table>
	<p>&#x2731; is one of [8|9|10|11|12|13|14|15]</p>
</div>

<div class="slide">
<h1>Stack and Instruction Registers</h1>
<table style="float: right; width: 30%;">
	<tr>
		<td>%rbp &#8594;</td>
		<td class="border dark">0xdead</td>
		<td>0x1000</td>
	</tr>
	<tr>
		<td></td>
		<td class="border dark">0xbeef</td>
		<td>0xff8</td>
	</tr>
	<tr>
		<td></td>
		<td class="border dark">0x1000</td>
		<td>0xff0</td>
	</tr>
	<tr>
		<td>%rsp &#8594;</td>
		<td class="border dark">0xfefe</td>
		<td>0xfe8</td>
	</tr>
	<tr>
		<td></td>
		<td class="border">&nbsp;</td>
		<td>0xfe0</td>
	</tr>
</table>
<ul>
	<li><em>RSP</em> - Stack Pointer, points to the current <em>top</em> of the stack</li>
	<ul>
		<li>But stack grows <em>down</em>!</li>
		<li>Operated by push/pop instructions</li>
	</ul>
	<li><em>RBP</em> - Base Pointer</li>
	<ul>
		<li>Base of this function's Stack Frame</li>
		<li>Optional use of GPR</li>
	</ul>
	<li><em>RIP</em> - Instruction Pointer</li>
	<ul>
		<li>Points to the byte <em>after</em> currently executed instruction</li>
		<li>Operated by call, jmp instructions</li>
		<li>Available for read-only (64-bit only)</li>
	</ul>
</ul>
</div>
</div>

<div class="slide">
<h1>Memory Management</h1>
<ul>
	<li>All instructions operate on <em>Virtual Memory</em></li>
	<ul>
		<li>VM is non-contiguous (depends on mapping) 64-bit linear address space</li>
		<li>In Intel terminology called <em>Linear Address</em></li>
	</ul>
	<li>VM is mapped to <em>Physical Memory</em></li>
	<ul>
		<li>PM is non-contiguous too (PCI space, SMM, &hellip;</li>
		<li>Called <em>Physical Address</em></li>
	</ul>
	<li>x86 supports two modes of VMM:</li>
	<ul>
		<li><em>Segmentation</em> - whole PM split between </em>segments</em></li>
		<li><em>Paging</em> - Each Virtual Page is mapped to given Physical Page</li>
		<li>Segmentation can't be turned off!</li>
		<ul>
		<li>&hellip; but can be made transparent</li>
		</ul>
	</ul>
</ul>
</div>

<div class="slide">
<h1>Memory Management (cont.)</h1>
<img height=70% alt="x86 VMM" src="images/x86-vmm.png"/>
<p class="right grey">Source: Intel Software Developer's Manual, Volume 3A, Figure 3-1</p>
</div>

<div class="slide">
<h1>Segment Registers</h1>
<ul>
	<li>Six 16-bit segment selector registers available:</li>
	<ul>
		<li><em>cs</em> - Code Segment</li>
		<li><em>ss</em> - Stack Segment</li>
		<li><em>ds</em> - Data Segment</li>
		<li><em>es, fs, gs</em> - Additional Data Segments</li>
	</ul>
</ul>
<table>
	<tr>
		<td colspan=14>15</td>
		<td>2</td>
		<td colspan=2>1</td>
	</tr>
	<tr class="border">
		<td colspan=14>Index</td>
		<td>TI</td>
		<td colspan=2>RPL</td>
	</tr>
</table>
<p><em>Index</em> - Offset / 8 into the Segment Descriptor Table</p>
<p><em>TI</em> - Table Indicator: 0 GDT, 1 LDT</p>
<p><em>RPL</em> - Requested Privilege Level</p>
</div>

<div class="slide">
<h1>Base Address Registers</h1>
<ul>
	<li>80-bit width pointers to the base of the table:</li>
	<ul>
		<li><em>GDTR</em> - Global Descriptor Table Register</li>
		<li><em>LDTR</em> - Local Descriptor Table Register (obsolete)</li>
		<li><em>IDTR</em> - Interrupt Descriptor Table Register</li>
	</ul>
	<li>Operated by <em>lgdt, sgdt, lldt, sldt</em> instructions</li>
</ul>
	<table>
		<tr>
			<td colspan=64>79</td>
			<td colspan=16>15</td>
		</tr>
		<tr class="border">
			<td colspan=64>Linear Base Address</td>
			<td colspan=16>Table Limit</td>
		</tr>
	</table>
</div>

<div class="slide">
<h1>Segment Descriptor</h1>
<ul>
	<li>A single item describing chunk of memory</li>
	<li>PMA = Base address + instruction offset</li>
	<li>Defined by base address &amp; limit</li>
	<li>Almost disabled in 64-bit mode</li>
	<ul>
		<li>%cs, %ds, %ss, %es base considered zero</li>
		<li>No limit checking</li>
		<li>But %fs and %gs are usable!</li>
	</ul>
</ul>
<img height=30% alt="Segment Descriptor" src="images/segment_descriptor.png"/>
<p class="right grey">Source: Intel Software Developer's Manual, Volume 3A, Figure 3-8</p>
</div>

<div class="slide">
<h1>Flags and features register</h1>
<ul>
	<li>64-bit %rflags</li>
	<ul>
		<li><em>CF</em> - Cary flag</li>
		<li><em>ZF</em> - Zero flag</li>
		<li><em>SF</em> - Sign flag</li>
		<li><em>IF</em> - Interrupts enabled flag</li>
	</ul>
	<li>Extended Feature Enable Register (EFER)</li>
	<ul>
		<li>Long Mode Enable (LME)</li>
		<li>Long Mode Active (LMA)</li>
	</ul>
</ul>
</div>

<div class="slide">
<h1>Control Registers</h1>
<ul>
	<li>%cr0</li>
	<ul>
		<li><em>PE</em> - Protected Mode enabled</li>
		<li><em>TS</em> - Task Switched, used for FPU</li>
		<li><em>PG</em> - Enable Paging (MMU)</li>
	</ul>
	<li>%cr1 - reserved</li>
	<li>%cr2 - Page Fault Linear Address</li>
	<li>%cr3 - Page Tables root</li>
	<li>%cr4</li>
	<ul>
		<li>Physical Address Extension (PAE)</li>
		<li>Machine Check Exception (MCE)</li>
		<li>Virtual Machine Extensions Enable (VMXE)</li>
	</ul>
	<li>%cr8 - TPR, interrupt priority mask (4 bits)</li>
</ul>
</div>

<div class="slide cover">
<br clear="all" />
<h1>x86 Assembly Language</h1>
</div>

<div class="slide">
<h1>Addressing modes</h1>
<ul>
	<li>x86 allows indirect addressing with offset, index and scale</li>
	<li>VMA = offset(%reg, %index, scale)</li>
	<li>VMA = offset + %reg + %index*scale</li>
	<ul>
		<li></em>%reg</em> is any GPR</li>
		<li><em>scale</em> is any from [1248]</li>
		<li><em>%index</em> is any GPR</li>
	</ul>
</ul>
</div>

<div class="slide">
<h1>Addressing modes - Example</h1>
<p>VMA = offset(%reg, %index, scale)</p>
<pre>
struct foo {
	int a;
	int b;
};

void bar(struct foo *a) {
	volatile int index = 3;
	printf("b: %d\n", a[index].b);
}
</pre>
<pre>
movl   $0x3,0xc(%rsp)
movslq 0xc(%rsp),%rax
mov    0x4(%rdi,%rax,8),%esi
</pre>
</div>

<div class="slide">
<h1>Assembly syntax</h1>
<ul>
	<li>Intel syntax vs. AT&amp;T syntax</li>
	<li>We'll use that later because that's what *NIX tools do</li>
</ul>
<table>
	<tr class="border">
	<th>Intel</th>
	<th>AT&amp;T</th>
	</tr>
	<tr>
		<td>
<pre>
movw $0x3, %rax
movq 0x8(%rax, %rcx, 2), %rsi
addl $0x1000, %esi
</pre>
		</td>
		<td>
<pre>
MOV AX, 0x3
MOV RSI, [ RAX + 2*RCX + 8 ]
ADD ESI, 0x1000
</pre>
		</td>
	</tr>
</table>
</div>

<div class="slide">
<h1>Basic load/store instructions</h1>
<ul>
	<li><em>mov</em> - Move data between registers and/or memory</li>
	<li><em>nop</em> - Do nothing, 1 byte, actually xchg %eax, %eax</li>
	<li><em>lea</em> - Load Effective Address, calculates address of memory operand</li>
</ul>
</div>

<div class="slide">
<h1>Basic arithmetics instructions</h1>
<ul>
	<li><em>add, sub</em> - Basic increment, decrement, sets flags register</li>
	<li><em>and, or, xor</em> - Bit operations, sets flags register</li>
	<li><em>inc, dec</em> - Increment, decrement by one</li>
</ul>
</div>

<div class="slide">
<h1>Conditionals</h1>
<ul>
	<li><em>cmp</em> - Subtract two operands, discrard result, set flags register</li>
	<li><em>test</em> - And two operands, discrad result, set flags register</li>
	<li><em>jmp</em> - Unconditional jump</li>
	<li><em>je, jnz, &hellip;</em> - Jump based on flags register</li>
</ul>
</div>

<div class="slide">
<h1>Conditionals - Example</h1>
<pre>
testb  $0x8,0x8(%r12)
jne    0x7f3efa731efe &lt;pthread_create@@GLIBC_2.2.5+1662&gt;
</pre>
</div>

<div class="slide">
<h1>Stack instructions</h1>
<ul>
	<li><em>push</em> - Decrement the %rsp <em>and</em> store the value</li>
	<li><em>pop</em> - Load the value <em>and</em> increment the %rsp</li>
	<li><em>call</em> - push %rip <em>and</em> set %rip to value</li>
	<li><em>ret</em> - pop %rip</li>
</ul>
</div>

<div class="slide cover">
 <br clear="all" />
 <h1>x86_86 System V ABI</h1>
</div>

<div class="slide">
<h1>ABI</h1>
<ul>
	<li>Document which defines the actual interface on given architecture</li>
	<li>Function calling convention</li>
	<li>Implicit stack usage</li>
	<li>Usage of register inside a function</li>
</ul>
</div>

<div class="slide">
<h1>x86_86 System V ABI</h1>
<ul>
	<li>Data mostly padded to 4-byte alignment</li>
	<ul>
		<li>Stack (%rsp + 8) is required to be 16-bytes aligned for SSE instructions</li>
	</ul>
	<li>First 6 arguments passed via <em>%rdi, %rsi, %rdx, %rcx, %r8, %r9</em>.</li>
	<li>The rest passed through the stack.</li>
	<li>Return value passed through <em>%rax</em>.</li>
	<li>Use push/pop for stack operations, use %rbp as base pointer.</li>
	<li>Scratch (volatile) registers: <em>%rax, %rcx, %rdx, %rdi, %rsi, %r8, %r9, %r10, %r11</em></li>
	<li>Preserved (non-volatile) registers: <em>%rbx, %rbp, %rsp, %r12, %r13, %r14, %r15</em></li>
</ul>
</div>

<div class="slide">
<h1>Structure padding</h1>
<pre>
struct foo {
	char a;
	int b;
};

printf("sizeof (struct foo): %d\n", sizeof (struct foo));
printf("offsetof(struct foo, b): %d\n", &((struct foo *)0)->b);
</pre>
</div>

<div class="slide">
<h1>Structure padding</h1>
<pre>
struct foo {
	char a;
	int b;
};

printf("sizeof (struct foo): %d\n", sizeof (struct foo));
printf("offsetof(struct foo, b): %d\n", &((struct foo *)0)->b);
</pre>
<pre>
sizeof (struct foo): 8
offsetof(struct foo, b): 4
</pre>
</div>

<div class="slide">
<h1>Function prolog</h1>
<ul>
	<li>&nbsp;</li>
	<li>&nbsp;</li>
</ul>
<pre>
Dump of assembler code for function pthread_create@@GLIBC_2.2.5:
   0x00007f3efa731880 <+0>:	push   %rbp
   0x00007f3efa731881 <+1>:	mov    %rsp,%rbp
   0x00007f3efa731884 <+4>:	push   %r15
   0x00007f3efa731886 <+6>:	push   %r14
   0x00007f3efa731888 <+8>:	push   %r13
   0x00007f3efa73188a <+10>:	push   %r12
   0x00007f3efa73188c <+12>:	mov    %rsi,%r12
   0x00007f3efa73188f <+15>:	push   %rbx
</pre>
</div>

<div class="slide">
<h1>Function prolog</h1>
<ul>
	<li>Create stack frame</li>
	<li>&nbsp;</li>
</ul>
<pre>
Dump of assembler code for function pthread_create@@GLIBC_2.2.5:
   0x00007f3efa731880 <+0>:	<span class="red">push   %rbp</span>
   0x00007f3efa731881 <+1>:	<span class="red">mov    %rsp,%rbp</span>
   0x00007f3efa731884 <+4>:	push   %r15
   0x00007f3efa731886 <+6>:	push   %r14
   0x00007f3efa731888 <+8>:	push   %r13
   0x00007f3efa73188a <+10>:	push   %r12
   0x00007f3efa73188c <+12>:	mov    %rsi,%r12
   0x00007f3efa73188f <+15>:	push   %rbx
</pre>
</div>

<div class="slide">
<h1>Function prolog</h1>
<ul>
	<li>Create stack frame</li>
	<li>Store non-volatile registers</li>
</ul>
<pre>
Dump of assembler code for function pthread_create@@GLIBC_2.2.5:
   0x00007f3efa731880 <+0>:	push   %rbp
   0x00007f3efa731881 <+1>:	mov    %rsp,%rbp
   0x00007f3efa731884 <+4>:	<span class="red">push   %r15</span>
   0x00007f3efa731886 <+6>:	<span class="red">push   %r14</span>
   0x00007f3efa731888 <+8>:	<span class="red">push   %r13</span>
   0x00007f3efa73188a <+10>:	<span class="red">push   %r12</span>
   0x00007f3efa73188c <+12>:	mov    %rsi,%r12
   0x00007f3efa73188f <+15>:	<span class="red">push   %rbx</span>
</pre>
</div>

<div class="slide">
<h1>Function epilog</h1>
<ul>
	<li>&nbsp;</li>
	<li>&nbsp;</li>
	<li>&nbsp;</li>
</ul>
<pre>
   0x00007f3efa731d89 <+1289>:	lea    -0x28(%rbp),%rsp
   0x00007f3efa731d8d <+1293>:	mov    %r8d,%eax
   0x00007f3efa731d90 <+1296>:	pop    %rbx
   0x00007f3efa731d91 <+1297>:	pop    %r12
   0x00007f3efa731d93 <+1299>:	pop    %r13
   0x00007f3efa731d95 <+1301>:	pop    %r14
   0x00007f3efa731d97 <+1303>:	pop    %r15
   0x00007f3efa731d99 <+1305>:	pop    %rbp
   0x00007f3efa731d9a <+1306>:	retq
</pre>
</div>

<div class="slide">
<h1>Function epilog</h1>
<ul>
	<li>Clean the stack variables</li>
	<li>&nbsp;</li>
	<li>&nbsp;</li>
</ul>
<pre>
   0x00007f3efa731d89 <+1289>:	<span class="red">lea    -0x28(%rbp),%rsp</span>
   0x00007f3efa731d8d <+1293>:	mov    %r8d,%eax
   0x00007f3efa731d90 <+1296>:	pop    %rbx
   0x00007f3efa731d91 <+1297>:	pop    %r12
   0x00007f3efa731d93 <+1299>:	pop    %r13
   0x00007f3efa731d95 <+1301>:	pop    %r14
   0x00007f3efa731d97 <+1303>:	pop    %r15
   0x00007f3efa731d99 <+1305>:	pop    %rbp
   0x00007f3efa731d9a <+1306>:	retq
</pre>
</div>

<div class="slide">
<h1>Function epilog</h1>
<ul>
	<li>Clean the stack variables</li>
	<li>Set the return value</li>
	<li>&nbsp;</li>
</ul>
<pre>
   0x00007f3efa731d89 <+1289>:	lea    -0x28(%rbp),%rsp
   0x00007f3efa731d8d <+1293>:	<span class="red">mov    %r8d,%eax</span>
   0x00007f3efa731d90 <+1296>:	pop    %rbx
   0x00007f3efa731d91 <+1297>:	pop    %r12
   0x00007f3efa731d93 <+1299>:	pop    %r13
   0x00007f3efa731d95 <+1301>:	pop    %r14
   0x00007f3efa731d97 <+1303>:	pop    %r15
   0x00007f3efa731d99 <+1305>:	pop    %rbp
   0x00007f3efa731d9a <+1306>:	retq
</pre>
</div>

<div class="slide">
<h1>Function epilog</h1>
<ul>
	<li>Clean the stack variables</li>
	<li>Set the return value</li>
	<li>Restore value of non-volatile registers</li>
</ul>
<pre>
   0x00007f3efa731d89 <+1289>:	lea    -0x28(%rbp),%rsp
   0x00007f3efa731d8d <+1293>:	mov    %r8d,%eax
   0x00007f3efa731d90 <+1296>:	<span class="red">pop    %rbx</span>
   0x00007f3efa731d91 <+1297>:	<span class="red">pop    %r12</span>
   0x00007f3efa731d93 <+1299>:	<span class="red">pop    %r13</span>
   0x00007f3efa731d95 <+1301>:	<span class="red">pop    %r14</span>
   0x00007f3efa731d97 <+1303>:	<span class="red">pop    %r15</span>
   0x00007f3efa731d99 <+1305>:	<span class="red">pop    %rbp</span>
   0x00007f3efa731d9a <+1306>:	retq
</pre>
</div>

<div class="slide">
<h1>Red zone</h1>
<ul>
<li>A reserved area below (out) the top of the stack</li>
<li>All other stacks (exception, trap) have to skip this area</li>
<li>Allowed for performance optimization</li>
<li>gcc -mno-red-zone</li>
</ul>
</div>

<div class="slide">
<h1>Stack operation</h1>
<ul>
	<li><em>Stack pointer (%rsp)</em> points to the last item on the stack</li>
	<li><em>Frame pointer (%rbp)</em> optionally points to the base of the stack frame.</li>
	<li><em>Stack frame</em> is the part of the stack used by the current function.<li>
</ul>
</div>

<div class="slide">
<h1>Stack operation animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	<span class="red">callq  0x4004d6 &lt;bar&gt;</span> &larr; %rip
   0x004004fd:	nop
bar:
   0x004004d6:	push   %rbp
   0x004004d7:	mov    %rsp,%rbp
   0x004004da:	mov    %edi,-0x4(%rbp)
   0x004004dd:	mov    %esi,-0x8(%rbp)
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	pop    %rbp
   0x004004e9:	retq
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe &larr; %rsp &larr; %rbp
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Stack operation animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	callq  0x4004d6 &lt;bar&gt;
   0x004004fd:	nop
bar:
   0x004004d6:	<span class="red">push   %rbp</span> &larr; %rip
   0x004004d7:	mov    %rsp,%rbp
   0x004004da:	mov    %edi,-0x4(%rbp)
   0x004004dd:	mov    %esi,-0x8(%rbp)
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	pop    %rbp
   0x004004e9:	retq
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe &larr; %rbp
0x1f8: 0x004004fd &larr; %rsp
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Stack operation animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	callq  0x4004d6 &lt;bar&gt;
   0x004004fd:	nop
bar:
   0x004004d6:	push   %rbp
   0x004004d7:	<span class="red">mov    %rsp,%rbp</span> &larr; %rip
   0x004004da:	mov    %edi,-0x4(%rbp)
   0x004004dd:	mov    %esi,-0x8(%rbp)
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	pop    %rbp
   0x004004e9:	retq
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe &larr; %rbp
0x1f8: 0x004004fd
0x1f0: 0x00000200 &larr; %rsp
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Stack operation animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	callq  0x4004d6 &lt;bar&gt;
   0x004004fd:	nop
bar:
   0x004004d6:	push   %rbp
   0x004004d7:	mov    %rsp,%rbp
   0x004004da:	<span class="red">mov    %edi,-0x4(%rbp)</span> &larr; %rip
   0x004004dd:	mov    %esi,-0x8(%rbp)
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	pop    %rbp
   0x004004e9:	retq
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe
0x1f8: 0x004004fd
0x1f0: 0x00000200 &larr; %rsp &larr; %rbp
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Stack operation animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	callq  0x4004d6 &lt;bar&gt;
   0x004004fd:	nop
bar:
   0x004004d6:	push   %rbp
   0x004004d7:	mov    %rsp,%rbp
   0x004004da:	mov    %edi,-0x4(%rbp)
   0x004004dd:	<span class="red">mov    %esi,-0x8(%rbp)</span> &larr; %rip
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	pop    %rbp
   0x004004e9:	retq
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe
0x1f8: 0x004004fd
0x1f0: 0x00000200 &larr; %rsp &larr; %rbp
0x1ec: 0x3 <span class="red">RED ZONE!</span>
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Stack operation animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	callq  0x4004d6 &lt;bar&gt;
   0x004004fd:	nop
bar:
   0x004004d6:	push   %rbp
   0x004004d7:	mov    %rsp,%rbp
   0x004004da:	mov    %edi,-0x4(%rbp)
   0x004004dd:	mov    %esi,-0x8(%rbp)
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	<span class="red">pop    %rbp</span> &larr; %rip
   0x004004e9:	retq
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe
0x1f8: 0x004004fd
0x1f0: 0x00000200 &larr; %rsp &larr; %rbp
0x1ec: 0x3 <span class="red">RED ZONE!</span>
0x1e8: 0x4 <span class="red">RED ZONE!</span>
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Stack operation animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	callq  0x4004d6 &lt;bar&gt;
   0x004004fd:	nop
bar:
   0x004004d6:	push   %rbp
   0x004004d7:	mov    %rsp,%rbp
   0x004004da:	mov    %edi,-0x4(%rbp)
   0x004004dd:	mov    %esi,-0x8(%rbp)
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	pop    %rbp
   0x004004e9:	<span class="red">retq</span> &larr; %rip
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe &larr; %rbp
0x1f8: 0x004004fd &larr; %rsp
0x1f0: 0x00000200
0x1ec: 0x3
0x1e8: 0x4
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Stack operation animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	callq  0x4004d6 &lt;bar&gt;
   0x004004fd:	<span class="red">nop</span> &larr; %rip
bar:
   0x004004d6:	push   %rbp
   0x004004d7:	mov    %rsp,%rbp
   0x004004da:	mov    %edi,-0x4(%rbp)
   0x004004dd:	mov    %esi,-0x8(%rbp)
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	pop    %rbp
   0x004004e9:	retq
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe &larr; %rbp &larr; %rsp
0x1f8: 0x004004fd
0x1f0: 0x00000200
0x1ec: 0x3
0x1e8: 0x4
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Things to remember</h1>
<ul>
	<li>The %rip address stored by <em>call</em> instruction points to the original code</li>
	<li>This address is used by debuggers to restore the call stack</li>
	<li>If the address is not stored on the stack, the function won't be visible in the stack trace</li>
	<ul>
		<li>Inlined functions<li>
		<li>Tail call optimization where function is "called" used <em>jmp</em> instruction</li>
	</ul>
	<li>The %rsp points to the first <em>unused</em> field on the stack</li>
	<li>(%rbp + 8) is required to be 16-bytes aligned by ABI</li>
</ul>
</div>

<div class="slide cover">
 <br clear="all" />
 <h1>Other architectures</h1>
</div>

<div class="slide">
<h1>Branch delay slot</h1>
<ul>
	<li>One instruction after the current one is <em>always</em> executed</li>
	<li>Even if the preceeding instruction has jumped elsewhere</li>
	<li>This is because the next instruction is already in the CPU pipeline</li>
	<li>This behavior can be seen on MIPS and SPARC CPUs.</li>
</ul>
</div>

<div class="slide">
<h1>TLB miss</h1>
<ul>
	<li><em>TLB</em> - Translation Lookaside Buffer</li>
	<li>A small associative cache used for fast VMA-&gt;PMA translation</li>
	<li>Skylake has ~4KB ITLB, ~4KB DTLB</li>
	<li>Other architectures don't maintain TLB automatically - <em>TLB miss</em> trap.</li>
</ul>
</div>

</body>
</html>
