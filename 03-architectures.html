<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <title>Binary Code Analysis - Architectures</title>
  <meta name="copyright"
    content="Copyright &#169; 2021 Stanislav Kozina <skozina@redhat.com>, Viktor Malik <vmalik@redhat.com>" />
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
   href="styles/slidy.css" />
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
   href="styles/w3c-blue.css" />
  <script src="scripts/slidy.js" charset="utf-8"
   type="text/javascript"></script>
  <link rel="stylesheet" type="text/css" href="styles/cda.css" />
</head>

<body>

<div class="background">
  <img id="head-icon" alt="graphic with four colored squares" src="images/bca.png" />
  <img src="images/Logo-RedHat-A-White-RGB.png" alt="RH logo" id="head-logo" />
</div>

<div class="slide cover">
 <div>
 <img src="images/Logo-RedHat-A-White-RGB.png" alt="RH logo" class="cover" />
 <br clear="all" />
 <h1>Binary Code Analysis</h1>
 <h2>Computer Architectures</h2>
 <p>Viktor Mal√≠k<br>
    Software Engineer, Red Hat<br></p>
 <p>Stanislav Kozina<br>
    Manager, Software Engineering, Red Hat<br></p>
 <p>&copy; January 2022</p>
 </div>
</div>

<div class="slide">
	<h1>Agenda</h1>
	<ul>
		<li>Computer architectures in general</li>
		<li>Registers</li>
		<li>The x86 and x86_64 computer architectures, common instructions</li>
		<li>Implicit and explicit stack operations</li>
		<li>System V ABI on x86_64 architecture</li>
	</ul>
</div>

<div class="slide">
	<h1>Agenda</h1>
	<ul>
		<li>Computer architectures in general</li>
		<li>Registers</li>
		<li><span class="red">The x86 and x86_64 computer architectures</span>, common instructions</li>
		<li>Implicit and explicit stack operations</li>
		<li>System V ABI on x86_64 architecture</span></li>
	</ul>
</div>

<div class="slide">
	<h1>History</h1>
	<ul>
		<li>1978: Intel 8086, 16bit, 20bit addressing, only real mode</li>
		<li>1982: Intel 80286, 16bit, 24bit addressing, protected
			mode, MMU</li>
		<li>1985: Intel 80386, 32bit</li>
		<ul>
			<li>Introduced the <b>IA-32</b> architecture</li>
			<li>Commonly called <b>x86</b>, which otherwise refers to 8086's and 80286's architecture, too</li>
			<li>Various versions called i386, i486, i586, i686 in GNU/Linux context</li>
		</ul>
		<li>2003: AMD Athlon 64, 64bit, 40bit addressing</li>
			<ul>
				<li>Introduced the <b>AMD64</b> (also <b>x86_64</b>, Intel 64) architecture</li>
				<li>Do <em>NOT</em> confuse with IA-64!</li>
				<li>That's Intel Itanium</li>
			</ul>
		<li>Today: Intel Comet Lake, 64bit, 46bit addressing</li>
	</ul>
	<img alt="Seattle Computer" src="images/Seattle_Computer_8086-2.jpg"/>
	<p class="grey">Source: http://www.s100computers.com</p>
</div>

<div class="slide">
	<h1>Features</h1>
	<ul>
		<li>FPU, MMX, SSE, PAE, SMP, VT-x, GPU, TSX, &hellip;</li>
		<li>Full backwards compatibility</li>
		<ul>
			<li>Except for segmentation changes, mandatory paging
				etc.</li>
		</ul>
		<li>Little endian</li>
		<li>Variable instruction length</li>
		<li>CISC</li>
		<ul>
			<li>Many, many instructions, often similar</li>
			<li>Src/Dst operands can be in memory</li>
			<li>RISC micro-instructions in the core anyway</li>
		</ul>
	</ul>
</div>

<div class="slide">
<h1>Variable Instruction Size</h1>
<pre>
(gdb) disassemble /r pthread_create
Dump of assembler code for function pthread_create@@GLIBC_2.2.5:
   55			push   %rbp
   48 89 e5		mov    %rsp,%rbp
   41 57		push   %r15
   41 56		push   %r14
   41 55		push   %r13
   41 54		push   %r12
   49 89 f4		mov    %rsi,%r12
   53			push   %rbx
   48 81 ec b8 00 00 00	sub    $0xb8,%rsp
   48 85 f6		test   %rsi,%rsi
   48 89 bd 50 ff ff ff	mov    %rdi,-0xb0(%rbp)
   48 89 b5 48 ff ff ff	mov    %rsi,-0xb8(%rbp)
   48 89 95 60 ff ff ff	mov    %rdx,-0xa0(%rbp)
   48 89 8d 58 ff ff ff	mov    %rcx,-0xa8(%rbp)
   c6 85 6f ff ff ff 00	movb   $0x0,-0x91(%rbp)
</pre>
</div>

<div class="slide">
	<h1>Little Endian</h1>
	<ul>
		<li>The way the CPU accesses <em>multi-byte</em> content.</li>
		<li>Makes difference in communication between different
			platforms</li>
		<ul>
			<li>RPC, Network byte ordering, DMA</li>
		</ul>
	</ul>
	<pre>
int a = 0x12345678;
</pre>
	<pre>
(gdb) x/4xb &a
0x60102c &lt;a&gt;:	0x78	0x56	0x34	0x12
</pre>
</div>

<div class="slide">
	<h1>32-bit General Purpose Registers (GPR)</h1>
	<ul>
		<li>Overlapping access to the single register</li>
		<li>Based on access width (8/16/32 bits)</li>
	</ul>
	<table>
		<tr>
			<td>32</td>
			<td>24</td>
			<td>16</td>
			<td>8</td>
		</tr>
		<tr class="border">
			<td colspan=4>%e&#x2731;x</td>
		</tr>
		<tr class="border">
			<td colspan=2 class="dark" style="width=50%;"></td>
			<td colspan=2>%&#x2731;x</td>
		</tr>
		<tr class="border">
			<td colspan=2 class="dark" style="width=50%;"></td>
			<td>%&#x2731;h</td>
			<td>%&#x2731;l</td>
		</tr>
	</table>
	<p>&#x2731; is one of [abcd]</p>
	<table>
		<tr>
			<td>32</td>
			<td>24</td>
			<td>16</td>
			<td>8</td>
		</tr>
		<tr class="border">
			<td colspan=4>%e&#x2731;</td>
		</tr>
		<tr class="border">
			<td colspan=2 class="dark" style="width=50%;"></td>
			<td colspan=2>%&#x2731;</td>
		</tr>
	</table>
	<p>&#x2731; is one of [di|si|bp|sp]</p>
</div>

<div class="slide">
	<h1>64-bit General Purpose Registers (GPR)</h1>
	<table>
		<tr>
			<td>64</td>
			<td>56</td>
			<td>48</td>
			<td>40</td>
			<td>32</td>
			<td>24</td>
			<td>16</td>
			<td>8</td>
		</tr>
		<tr class="border">
			<td colspan=8>%r&#x2731;x</td>
		</tr>
		<tr class="border">
			<td colspan=4 class="dark" style="width=50%;"></td>
			<td colspan=4>%e&#x2731;x</td>
		</tr>
		<tr class="border">
			<td colspan=6 class="dark" style="width=50%;"></td>
			<td colspan=2>%&#x2731;x</td>
		</tr>
		<tr class="border">
			<td colspan=6 class="dark" style="width=50%;"></td>
			<td class="dark">%&#x2731;h</td>
			<td>%&#x2731;l</td>
		</tr>
	</table>
	<p>&#x2731; is one of [abcd]; The %&#x2731;h are deprecated</p>
	<table>
		<tr>
			<td>64</td>
			<td>56</td>
			<td>48</td>
			<td>40</td>
			<td>32</td>
			<td>24</td>
			<td>16</td>
			<td>8</td>
		</tr>
		<tr class="border">
			<td colspan=8>%r&#x2731;</td>
		</tr>
		<tr class="border">
			<td colspan=4 class="dark" style="width=50%;"></td>
			<td colspan=4>%e&#x2731;</td>
		</tr>
		<tr class="border">
			<td colspan=6 class="dark" style="width=50%;"></td>
			<td colspan=2>%&#x2731;</td>
		</tr>
		<tr class="border">
			<td colspan=7 class="dark" style="width=50%;"></td>
			<td>%&#x2731;l</td>
		</tr>
	</table>
	<p>&#x2731; is one of [di|si|bp|sp]</p>
	<p>Also, %rip / %eip / %ip pointing to the <em>next</em> instruction to
	execute is available for reading</p>
</div>

<div class="slide">
	<h1>64-bit General Purpose Registers (GPR) cont.</h1>
	<table>
		<tr>
			<td>64</td>
			<td>56</td>
			<td>48</td>
			<td>40</td>
			<td>32</td>
			<td>24</td>
			<td>16</td>
			<td>8</td>
		</tr>
		<tr class="border">
			<td colspan=8>%r&#x2731;</td>
		</tr>
		<tr class="border">
			<td colspan=4 class="dark" style="width=50%;"></td>
			<td colspan=4>%r&#x2731;d</td>
		</tr>
		<tr class="border">
			<td colspan=6 class="dark" style="width=50%;"></td>
			<td colspan=2>%r&#x2731;w</td>
		</tr>
		<tr class="border">
			<td colspan=7 class="dark" style="width=50%;"></td>
			<td>r%&#x2731;b</td>
		</tr>
	</table>
	<p>&#x2731; is one of [8|9|10|11|12|13|14|15]</p>
</div>

<div class="slide">
<h1>Stack and Instruction Registers</h1>
<table style="float: right; width: 30%;">
	<tr>
		<td>%rbp &#8594;</td>
		<td class="border dark">0xdead</td>
		<td>0x1000</td>
	</tr>
	<tr>
		<td></td>
		<td class="border dark">0xbeef</td>
		<td>0xff8</td>
	</tr>
	<tr>
		<td></td>
		<td class="border dark">0x1000</td>
		<td>0xff0</td>
	</tr>
	<tr>
		<td>%rsp &#8594;</td>
		<td class="border dark">0xfefe</td>
		<td>0xfe8</td>
	</tr>
	<tr>
		<td></td>
		<td class="border">&nbsp;</td>
		<td>0xfe0</td>
	</tr>
</table>
<ul>
	<li><em>RSP</em> - Stack Pointer, points to the current <em>top</em> of the stack</li>
	<ul>
		<li>But stack grows <em>down</em>!</li>
		<li>Operated by push/pop instructions</li>
	</ul>
	<li><em>RBP</em> - Base Pointer</li>
	<ul>
		<li>Base of this function's Stack Frame</li>
		<li>Optional use of GPR</li>
	</ul>
	<li><em>RIP</em> - Instruction Pointer</li>
	<ul>
		<li>Points to the byte <em>after</em> currently executed instruction</li>
		<li>Operated by call, jmp instructions</li>
		<li>Available for read-only (64-bit only)</li>
	</ul>
</ul>
</div>
</div>

<div class="slide">
<h1>x86 Memory Management</h1>
<ul>
	<li>All instructions operate on <em>Virtual Memory</em></li>
	<ul>
		<li>VM is non-contiguous (depends on mapping) 64-bit linear address space</li>
		<li>In Intel terminology called <em>Linear Address</em></li>
	</ul>
	<li>VM is mapped to <em>Physical Memory</em></li>
	<ul>
		<li>PM is non-contiguous too (PCI space, SMM, &hellip;)</li>
		<li>Called <em>Physical Address</em></li>
	</ul>
	<li>x86 supports two modes of VMM:</li>
	<ul>
		<li><em>Segmentation</em> - linear space split between </em>segments</em></li>
		<li><em>Paging</em> - each virtual page is mapped to given Physical Page</li>
		<li>Segmentation can't be turned off!</li>
		<ul>
		<li>&hellip; but can be made transparent</li>
		</ul>
	</ul>
</ul>
</div>

<div class="slide">
<h1>Real Mode (8086) Segmentation</h1>
<ul>
	<li>16bit registers, 20bit addressing</li>
	<li>Segment registers CS, DS, ES, GS</li>
	<li>16bit segment, 16bit offset</li>
	<li>20bit address = segment &lt;&lt; 4 + offset</li>
	<li>4096 combinations to compute the same physical address</li>
</ul>
<table border="1">
	<tr>
		<td>0010</td>
		<td>1010</td>
		<td>0010</td>
		<td>1000</td>
		<td>&nbsp;</td>
	</tr>
	<tr>
		<td>&nbsp;</td>
		<td>0010</td>
		<td>1010</td>
		<td>1000</td>
		<td>0010</td>
	</tr>
</table>
</div>

<div class="slide">
<h1>Protected Mode (80386) Memory Management</h1>
<img height=70% alt="x86 VMM" src="images/x86-vmm.png"/>
<p class="right grey">Source: Intel Software Developer's Manual, Volume 3A, Figure 3-1</p>
</div>

<div class="slide">
<h1>Segment Registers</h1>
<ul>
	<li>Six 16-bit segment selector registers available:</li>
	<ul>
		<li><em>cs</em> - Code Segment</li>
		<li><em>ss</em> - Stack Segment</li>
		<li><em>ds</em> - Data Segment</li>
		<li><em>es, fs, gs</em> - Additional Data Segments</li>
	</ul>
</ul>
<table>
	<tr>
		<td colspan=14>15</td>
		<td>2</td>
		<td colspan=2>1</td>
	</tr>
	<tr class="border">
		<td colspan=14>Index</td>
		<td>TI</td>
		<td colspan=2>RPL</td>
	</tr>
</table>
<p><em>Index</em> - Offset / 8 into the Segment Descriptor Table</p>
<p><em>TI</em> - Table Indicator: 0 GDT, 1 LDT</p>
<p><em>RPL</em> - Requested Privilege Level</p>
</div>

<div class="slide">
<h1>Base Address Registers</h1>
<ul>
	<li>80-bit width pointers to the base of the table:</li>
	<ul>
		<li><em>GDTR</em> - Global Descriptor Table Register</li>
		<li><em>LDTR</em> - Local Descriptor Table Register (obsolete)</li>
		<li><em>IDTR</em> - Interrupt Descriptor Table Register</li>
	</ul>
	<li>Operated by <em>lgdt, sgdt, lldt, sldt</em> instructions</li>
</ul>
	<table>
		<tr>
			<td colspan=64>79</td>
			<td colspan=16>15</td>
		</tr>
		<tr class="border">
			<td colspan=64>Linear Base Address</td>
			<td colspan=16>Table Limit</td>
		</tr>
	</table>
</div>

<div class="slide">
<h1>Segment Descriptor</h1>
<ul>
	<li>A single item describing chunk of memory</li>
	<li>PMA = Base address + instruction offset</li>
	<li>Defined by base address &amp; limit</li>
	<li>Almost disabled in 64-bit mode</li>
	<ul>
		<li>%cs, %ds, %ss, %es base considered zero</li>
		<li>No limit checking</li>
		<li>But %fs and %gs are usable!</li>
		<ul>
			<li>Used to access per-cpu data</li>
		</ul>
	</ul>
</ul>
<img height=30% alt="Segment Descriptor" src="images/segment_descriptor.png"/>
<p class="right grey">Source: Intel Software Developer's Manual, Volume 3A, Figure 3-8</p>
</div>

<div class="slide">
<h1>Per CPU Data</h1>
<pre>
asmlinkage __visible void __sched schedule(void)
{
	struct task_struct *tsk = current;
&hellip;
</pre>
<pre>
crash&gt; dis schedule
0xffffffffb3009b30 &lt;schedule&gt;:  nopl   0x0(%rax,%rax,1) [FTRACE NOP]
0xffffffffb3009b35 &lt;schedule+5&gt;:        mov    %gs:0x15b80,%rax
&hellip;
</pre>
</div>

<div class="slide">
<h1>Segment Descriptor cont.</h1>
<ul>
	<li>Special type of the segment descriptor is the <em>Task State Segment (TSS)</em></li>
	<li>Originally TSS was meant for hardware assisted task switching</em></li>
	<ul>
		<li>Which is not supported in 64-bit mode any more</li>
	</ul>
	<li>But is also used for setting the %rsp for switching between the privilege levels</li>
	<ul>
		<li>On interrupt the %rsp is loaded from the TSS</li>
	</ul>
</ul>
</div>

<div class="slide">
<h1>Flags and Features Register</h1>
<ul>
	<li>64-bit %rflags</li>
	<ul>
		<li><em>CF</em> - Cary flag</li>
		<li><em>ZF</em> - Zero flag</li>
		<li><em>SF</em> - Sign flag</li>
		<li><em>IF</em> - Interrupts enabled flag</li>
	</ul>
	<li>Extended Feature Enable Register (EFER)</li>
	<ul>
		<li>Long Mode Enable (LME)</li>
		<li>Long Mode Active (LMA)</li>
	</ul>
</ul>
</div>

<div class="slide">
<h1>Control Registers</h1>
<ul>
	<li>%cr0</li>
	<ul>
		<li><em>PE</em> - Protected Mode enabled</li>
		<li><em>TS</em> - Task Switched, used for FPU</li>
		<li><em>PG</em> - Enable Paging (MMU)</li>
	</ul>
	<li>%cr1 - reserved</li>
	<li>%cr2 - Page Fault Linear Address</li>
	<li>%cr3 - Page Tables root</li>
	<li>%cr4</li>
	<ul>
		<li>Physical Address Extension (PAE)</li>
		<li>Machine Check Exception (MCE)</li>
		<li>Virtual Machine Extensions Enable (VMXE)</li>
	</ul>
	<li>%cr8 - TPR, interrupt priority mask (4 bits)</li>
</ul>
</div>

<div class="slide cover">
<br clear="all" />
<h1>x86 Assembly Language</h1>
</div>

<div class="slide">
<h1>Assembly Syntax</h1>
<ul>
	<li>Intel syntax vs. AT&amp;T syntax</li>
	<li>We'll use the latter because that's what *NIX tools do</li>
</ul>
<table>
	<tr class="border">
	<th>AT&amp;T</th>
	<th>Intel</th>
	</tr>
	<tr>
		<td>
<pre>
movw $0x3, %rax
movq 0x8(%rax, %rcx, 2), %rsi
addl $0x1000, %esi
</pre>
		</td>
		<td>
<pre>
MOV AX, 0x3
MOV RSI, [ RAX + 2*RCX + 8 ]
ADD ESI, 0x1000
</pre>
		</td>
	</tr>
</table>
</div>

<div class="slide">
<h1>Addressing Modes</h1>
<ul>
	<li>x86 allows indirect addressing with offset, index and scale</li>
	<li>VMA = offset(%reg, %index, scale)</li>
	<li>VMA = offset + %reg + %index*scale</li>
	<ul>
		<li></em>%reg</em> is any GPR</li>
		<li><em>scale</em> is any from [1248]</li>
		<li><em>%index</em> is any GPR</li>
	</ul>
</ul>
</div>

<div class="slide">
<h1>Addressing Modes - Example</h1>
<p>VMA = offset(%reg, %index, scale)</p>
<pre>
struct foo {
	int a;
	int b;
};

void bar(struct foo *a) {
	volatile int index = 3;
	printf("b: %d\n", a[index].b);
}
</pre>
<pre>
movl   $0x3,0xc(%rsp)
movslq 0xc(%rsp),%rax
mov    0x4(%rdi,%rax,8),%esi
</pre>
</div>

<div class="slide">
<h1>Basic Load/Store Instructions</h1>
<ul>
	<li><em>mov</em> - Move data between registers and/or memory</li>
	<li><em>nop</em> - Do nothing, 1 byte, actually xchg %eax, %eax</li>
	<li><em>lea</em> - Load Effective Address, calculates address of memory operand</li>
</ul>
</div>

<div class="slide">
<h1>Basic Arithmetic Instructions</h1>
<ul>
	<li><em>add, sub</em> - Basic increment, decrement, sets flags register</li>
	<li><em>and, or, xor</em> - Bit operations, sets flags register</li>
	<li><em>inc, dec</em> - Increment, decrement by one</li>
</ul>
</div>

<div class="slide">
<h1>Conditionals</h1>
<ul>
	<li><em>cmp</em> - Subtract two operands, discard result, set flags register</li>
	<li><em>test</em> - And two operands, discard result, set flags register</li>
	<li><em>jmp</em> - Unconditional jump</li>
	<li><em>je, jnz, &hellip;</em> - Jump based on flags register</li>
</ul>
</div>

<div class="slide">
<h1>Conditionals - Example</h1>
<pre>
testb  $0x8,0x8(%r12)
jne    0x7f3efa731efe &lt;pthread_create@@GLIBC_2.2.5+1662&gt;
</pre>
</div>

<div class="slide">
<h1>Stack Instructions</h1>
<ul>
	<li><em>push</em> - Decrement the %rsp <em>and</em> store the value</li>
	<li><em>pop</em> - Load the value <em>and</em> increment the %rsp</li>
	<li><em>call</em> - push %rip <em>and</em> set %rip to value</li>
	<li><em>ret</em> - pop %rip</li>
</ul>
</div>

<div class="slide cover">
 <br clear="all" />
 <h1>x86_64 System V ABI</h1>
</div>

<div class="slide">
<h1>ABI</h1>
<ul>
	<li>Document which defines the actual interface on given architecture</li>
	<li>Function calling convention</li>
	<li>Implicit stack usage</li>
	<li>Usage of register inside a function</li>
</ul>
</div>

<div class="slide">
<h1>x86_64 System V ABI</h1>
<ul>
	<li>Data mostly padded to 4-byte alignment</li>
	<ul>
		<li>Stack (%rsp + 8) is required to be 16-bytes aligned for SSE instructions</li>
	</ul>
	<li>First 6 arguments passed via <em>%rdi, %rsi, %rdx, %rcx, %r8, %r9</em>.</li>
	<li>The rest passed through the stack.</li>
	<li>Return value passed through <em>%rax</em>.</li>
	<li>Use push/pop for stack operations, use %rbp as base pointer.</li>
	<li>Scratch (volatile) registers: <em>%rax, %rcx, %rdx, %rdi, %rsi, %r8, %r9, %r10, %r11</em></li>
	<li>Preserved (non-volatile) registers: <em>%rbx, %rbp, %rsp, %r12, %r13, %r14, %r15</em></li>
</ul>
</div>

<div class="slide">
<h1>Structure Padding</h1>
<pre>
struct foo {
	char a;
	int b;
};

printf("sizeof (struct foo): %d\n", sizeof (struct foo));
printf("offsetof(struct foo, b): %d\n", &((struct foo *)0)->b);
</pre>
</div>

<div class="slide">
<h1>Structure Padding</h1>
<pre>
struct foo {
	char a;
	int b;
};

printf("sizeof (struct foo): %d\n", sizeof (struct foo));
printf("offsetof(struct foo, b): %d\n", &((struct foo *)0)->b);
</pre>
<pre>
sizeof (struct foo): 8
offsetof(struct foo, b): 4
</pre>
</div>

<div class="slide">
<h1>Function Prolog</h1>
<ul>
	<li>&nbsp;</li>
	<li>&nbsp;</li>
</ul>
<pre>
Dump of assembler code for function pthread_create@@GLIBC_2.2.5:
   0x00007f3efa731880 <+0>:	push   %rbp
   0x00007f3efa731881 <+1>:	mov    %rsp,%rbp
   0x00007f3efa731884 <+4>:	push   %r15
   0x00007f3efa731886 <+6>:	push   %r14
   0x00007f3efa731888 <+8>:	push   %r13
   0x00007f3efa73188a <+10>:	push   %r12
   0x00007f3efa73188c <+12>:	mov    %rsi,%r12
   0x00007f3efa73188f <+15>:	push   %rbx
</pre>
</div>

<div class="slide">
<h1>Function Prolog</h1>
<ul>
	<li>Create stack frame</li>
	<li>&nbsp;</li>
</ul>
<pre>
Dump of assembler code for function pthread_create@@GLIBC_2.2.5:
   0x00007f3efa731880 <+0>:	<span class="red">push   %rbp</span>
   0x00007f3efa731881 <+1>:	<span class="red">mov    %rsp,%rbp</span>
   0x00007f3efa731884 <+4>:	push   %r15
   0x00007f3efa731886 <+6>:	push   %r14
   0x00007f3efa731888 <+8>:	push   %r13
   0x00007f3efa73188a <+10>:	push   %r12
   0x00007f3efa73188c <+12>:	mov    %rsi,%r12
   0x00007f3efa73188f <+15>:	push   %rbx
</pre>
</div>

<div class="slide">
<h1>Function Prolog</h1>
<ul>
	<li>Create stack frame</li>
	<li>Store non-volatile registers</li>
</ul>
<pre>
Dump of assembler code for function pthread_create@@GLIBC_2.2.5:
   0x00007f3efa731880 <+0>:	push   %rbp
   0x00007f3efa731881 <+1>:	mov    %rsp,%rbp
   0x00007f3efa731884 <+4>:	<span class="red">push   %r15</span>
   0x00007f3efa731886 <+6>:	<span class="red">push   %r14</span>
   0x00007f3efa731888 <+8>:	<span class="red">push   %r13</span>
   0x00007f3efa73188a <+10>:	<span class="red">push   %r12</span>
   0x00007f3efa73188c <+12>:	mov    %rsi,%r12
   0x00007f3efa73188f <+15>:	<span class="red">push   %rbx</span>
</pre>
</div>

<div class="slide">
<h1>Function Epilog</h1>
<ul>
	<li>&nbsp;</li>
	<li>&nbsp;</li>
	<li>&nbsp;</li>
</ul>
<pre>
   0x00007f3efa731d89 <+1289>:	lea    -0x28(%rbp),%rsp
   0x00007f3efa731d8d <+1293>:	mov    %r8d,%eax
   0x00007f3efa731d90 <+1296>:	pop    %rbx
   0x00007f3efa731d91 <+1297>:	pop    %r12
   0x00007f3efa731d93 <+1299>:	pop    %r13
   0x00007f3efa731d95 <+1301>:	pop    %r14
   0x00007f3efa731d97 <+1303>:	pop    %r15
   0x00007f3efa731d99 <+1305>:	pop    %rbp
   0x00007f3efa731d9a <+1306>:	retq
</pre>
</div>

<div class="slide">
<h1>Function Epilog</h1>
<ul>
	<li>Clean the stack variables</li>
	<li>&nbsp;</li>
	<li>&nbsp;</li>
</ul>
<pre>
   0x00007f3efa731d89 <+1289>:	<span class="red">lea    -0x28(%rbp),%rsp</span>
   0x00007f3efa731d8d <+1293>:	mov    %r8d,%eax
   0x00007f3efa731d90 <+1296>:	pop    %rbx
   0x00007f3efa731d91 <+1297>:	pop    %r12
   0x00007f3efa731d93 <+1299>:	pop    %r13
   0x00007f3efa731d95 <+1301>:	pop    %r14
   0x00007f3efa731d97 <+1303>:	pop    %r15
   0x00007f3efa731d99 <+1305>:	pop    %rbp
   0x00007f3efa731d9a <+1306>:	retq
</pre>
</div>

<div class="slide">
<h1>Function Epilog</h1>
<ul>
	<li>Clean the stack variables</li>
	<li>Set the return value</li>
	<li>&nbsp;</li>
</ul>
<pre>
   0x00007f3efa731d89 <+1289>:	lea    -0x28(%rbp),%rsp
   0x00007f3efa731d8d <+1293>:	<span class="red">mov    %r8d,%eax</span>
   0x00007f3efa731d90 <+1296>:	pop    %rbx
   0x00007f3efa731d91 <+1297>:	pop    %r12
   0x00007f3efa731d93 <+1299>:	pop    %r13
   0x00007f3efa731d95 <+1301>:	pop    %r14
   0x00007f3efa731d97 <+1303>:	pop    %r15
   0x00007f3efa731d99 <+1305>:	pop    %rbp
   0x00007f3efa731d9a <+1306>:	retq
</pre>
</div>

<div class="slide">
<h1>Function Epilog</h1>
<ul>
	<li>Clean the stack variables</li>
	<li>Set the return value</li>
	<li>Restore value of non-volatile registers</li>
</ul>
<pre>
   0x00007f3efa731d89 <+1289>:	lea    -0x28(%rbp),%rsp
   0x00007f3efa731d8d <+1293>:	mov    %r8d,%eax
   0x00007f3efa731d90 <+1296>:	<span class="red">pop    %rbx</span>
   0x00007f3efa731d91 <+1297>:	<span class="red">pop    %r12</span>
   0x00007f3efa731d93 <+1299>:	<span class="red">pop    %r13</span>
   0x00007f3efa731d95 <+1301>:	<span class="red">pop    %r14</span>
   0x00007f3efa731d97 <+1303>:	<span class="red">pop    %r15</span>
   0x00007f3efa731d99 <+1305>:	pop    %rbp
   0x00007f3efa731d9a <+1306>:	retq
</pre>
</div>

<div class="slide">
<h1>Red Zone</h1>
<ul>
<li>A reserved area below (out) the top of the stack</li>
<li>All other stacks (exception, trap) have to skip this area</li>
<li>Allowed for performance optimization</li>
<li>gcc -mno-red-zone</li>
</ul>
</div>

<div class="slide">
<h1>Stack Operation</h1>
<ul>
	<li><em>Stack pointer (%rsp)</em> points to the last item on the stack</li>
	<li><em>Frame pointer (%rbp)</em> optionally points to the base of the stack frame.</li>
	<li><em>Stack frame</em> is the part of the stack used by the current function.<li>
</ul>
</div>

<div class="slide">
<h1>Stack Operation Animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	<span class="red">callq  0x4004d6 &lt;bar&gt;</span> &larr; %rip
   0x004004fd:	nop
bar:
   0x004004d6:	push   %rbp
   0x004004d7:	mov    %rsp,%rbp
   0x004004da:	mov    %edi,-0x4(%rbp)
   0x004004dd:	mov    %esi,-0x8(%rbp)
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	pop    %rbp
   0x004004e9:	retq
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe &larr; %rsp &larr; %rbp
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Stack Operation Animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	callq  0x4004d6 &lt;bar&gt;
   0x004004fd:	nop
bar:
   0x004004d6:	<span class="red">push   %rbp</span> &larr; %rip
   0x004004d7:	mov    %rsp,%rbp
   0x004004da:	mov    %edi,-0x4(%rbp)
   0x004004dd:	mov    %esi,-0x8(%rbp)
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	pop    %rbp
   0x004004e9:	retq
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe &larr; %rbp
0x1f8: 0x004004fd &larr; %rsp
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Stack Operation Animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	callq  0x4004d6 &lt;bar&gt;
   0x004004fd:	nop
bar:
   0x004004d6:	push   %rbp
   0x004004d7:	<span class="red">mov    %rsp,%rbp</span> &larr; %rip
   0x004004da:	mov    %edi,-0x4(%rbp)
   0x004004dd:	mov    %esi,-0x8(%rbp)
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	pop    %rbp
   0x004004e9:	retq
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe &larr; %rbp
0x1f8: 0x004004fd
0x1f0: 0x00000200 &larr; %rsp
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Stack Operation Animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	callq  0x4004d6 &lt;bar&gt;
   0x004004fd:	nop
bar:
   0x004004d6:	push   %rbp
   0x004004d7:	mov    %rsp,%rbp
   0x004004da:	<span class="red">mov    %edi,-0x4(%rbp)</span> &larr; %rip
   0x004004dd:	mov    %esi,-0x8(%rbp)
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	pop    %rbp
   0x004004e9:	retq
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe
0x1f8: 0x004004fd
0x1f0: 0x00000200 &larr; %rsp &larr; %rbp
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Stack Operation Animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	callq  0x4004d6 &lt;bar&gt;
   0x004004fd:	nop
bar:
   0x004004d6:	push   %rbp
   0x004004d7:	mov    %rsp,%rbp
   0x004004da:	mov    %edi,-0x4(%rbp)
   0x004004dd:	<span class="red">mov    %esi,-0x8(%rbp)</span> &larr; %rip
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	pop    %rbp
   0x004004e9:	retq
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe
0x1f8: 0x004004fd
0x1f0: 0x00000200 &larr; %rsp &larr; %rbp
0x1ec: 0x3 <span class="red">RED ZONE!</span>
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Stack Operation Animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	callq  0x4004d6 &lt;bar&gt;
   0x004004fd:	nop
bar:
   0x004004d6:	push   %rbp
   0x004004d7:	mov    %rsp,%rbp
   0x004004da:	mov    %edi,-0x4(%rbp)
   0x004004dd:	mov    %esi,-0x8(%rbp)
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	<span class="red">pop    %rbp</span> &larr; %rip
   0x004004e9:	retq
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe
0x1f8: 0x004004fd
0x1f0: 0x00000200 &larr; %rsp &larr; %rbp
0x1ec: 0x3 <span class="red">RED ZONE!</span>
0x1e8: 0x4 <span class="red">RED ZONE!</span>
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Stack Operation Animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	callq  0x4004d6 &lt;bar&gt;
   0x004004fd:	nop
bar:
   0x004004d6:	push   %rbp
   0x004004d7:	mov    %rsp,%rbp
   0x004004da:	mov    %edi,-0x4(%rbp)
   0x004004dd:	mov    %esi,-0x8(%rbp)
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	pop    %rbp
   0x004004e9:	<span class="red">retq</span> &larr; %rip
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe &larr; %rbp
0x1f8: 0x004004fd &larr; %rsp
0x1f0: 0x00000200
0x1ec: 0x3
0x1e8: 0x4
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Stack Operation Animation</h1>
<div class="table">
<div>
<pre>
foo:
...
   0x004004ee:	mov    $0x4,%esi
   0x004004f3:	mov    $0x3,%edi
   0x004004f8:	callq  0x4004d6 &lt;bar&gt;
   0x004004fd:	<span class="red">nop</span> &larr; %rip
bar:
   0x004004d6:	push   %rbp
   0x004004d7:	mov    %rsp,%rbp
   0x004004da:	mov    %edi,-0x4(%rbp)
   0x004004dd:	mov    %esi,-0x8(%rbp)
   0x004004e0:	mov    -0x4(%rbp),%edx
   0x004004e3:	mov    -0x8(%rbp),%eax
   0x004004e6:	add    %edx,%eax
   0x004004e8:	pop    %rbp
   0x004004e9:	retq
</pre>
</div>
<div class="fill">
<pre>
0x200: 0xdeadbabe &larr; %rbp &larr; %rsp
0x1f8: 0x004004fd
0x1f0: 0x00000200
0x1ec: 0x3
0x1e8: 0x4
</pre>
</div>
</div>
</div>

<div class="slide">
<h1>Things To Remember</h1>
<ul>
	<li>The %rip address stored by <em>call</em> instruction points to the instruction after the call</li>
	<li>This address is used by debuggers to restore the call stack</li>
	<li>If the address is not stored on the stack, the function won't be visible in the stack trace</li>
	<ul>
		<li>Inlined functions<li>
		<li>Tail call optimization where function is "called" using the <em>jmp</em> instruction</li>
	</ul>
	<li>The %rsp points to the last <em>occupied</em> field on the stack</li>
	<ul>
		<li><em>push</em> instruction first decrements %rsp, then stores the value</li>
	</ul>
	<li>(%rbp + 8) is required to be 16-bytes aligned by ABI</li>
</ul>
</div>

<div class="slide">
<h1>Multiple Stacks</h1>
<ul>
	<li>On privilege level switch the new stack is loaded from TSS</li>
	<li>Kernel has its own stack</li>
	<li>Old register content is stored on the old stack, then $rsp is loaded from TSS</li>
	<li>Privilege level switch can happen on interrupt, trap (syscall), fault (GPF) or abort</li>
	<li>Faults and aborts can be nested, this creates additional stack frame on the kernel stack</li>
</ul>
</div>

<div class="slide">
<h1>Compiler Optimizations</h1>
<ul>
	<li>Compilers try to be smart on many things:</li>
	<ul>
		<li>Function inlining</li>
		<li>Tail call / leaf optimizations</li>
		<li>Remove unused variables</li>
		<li>Reorder independent operations</li>
		<li>Align data</li>
	</ul>
	<li>Do <em>not</em> confuse compiler reordering with machine reordering!</li>
	<li>Some things can't be optimized out</li>
	<ul>
		<li>External symbols</li>
		<li>volatile memory access</li>
	</ul>
<pre>
gcc -O[0123]
</pre>
</div>

<div class="slide">
<h1>-O0 Optimization Example</h1>
<ul>
	<li>&nbsp;</li>
	<li>&nbsp;</li>
</ul>
<table>
<tr>
<td>
<pre>
void print_sum(int a, int b) {
	printf("%d\n", a + b);
}

int main(int argc, char **argv) {
	print_sum(5,4);
	return (0);
}
</pre>
<pre>
$ gcc --version
gcc (GCC) 6.2.1 20160916 (Red Hat 6.2.1-2)
$ gcc -Wall -O0 -otest test.c
</pre>
</td>
<td>
<pre>
$ gdb test
(gdb) disassemble print_sum
Dump of assembler code for function print_sum:
&lt;+0&gt;:	push   %rbp
&lt;+1&gt;:	mov    %rsp,%rbp
&lt;+4&gt;:	sub    $0x10,%rsp
&lt;+8&gt;:	mov    %edi,-0x4(%rbp)
&lt;+11&gt;:	mov    %esi,-0x8(%rbp)
&lt;+14&gt;:	mov    -0x4(%rbp),%edx
&lt;+17&gt;:	mov    -0x8(%rbp),%eax
&lt;+20&gt;:	add    %edx,%eax
&lt;+22&gt;:	mov    %eax,%esi
&lt;+24&gt;:	mov    $0x400610,%edi
&lt;+29&gt;:	mov    $0x0,%eax
&lt;+34&gt;:	callq  0x400400 &lt;printf@plt&gt;
&lt;+39&gt;:	nop
&lt;+40&gt;:	leaveq
&lt;+41&gt;:	retq
</pre>
</td>
</tr>
</table>
</div>

<div class="slide">
<h1>-O0 Optimization Example</h1>
<ul>
	<li>Stack space allocation</li>
	<li>&nbsp;</li>
</ul>
<table>
<tr>
<td>
<pre>
void print_sum(int a, int b) {
	printf("%d\n", a + b);
}

int main(int argc, char **argv) {
	print_sum(5,4);
	return (0);
}
</pre>
<pre>
$ gcc --version
gcc (GCC) 6.2.1 20160916 (Red Hat 6.2.1-2)
$ gcc -Wall -O0 -otest test.c
</pre>
</td>
<td>
<pre>
$ gdb test
(gdb) disassemble print_sum
Dump of assembler code for function print_sum:
&lt;+0&gt;:	push   %rbp
&lt;+1&gt;:	mov    %rsp,%rbp
&lt;+4&gt;:	<span class="red">sub    $0x10,%rsp</span>
&lt;+8&gt;:	mov    %edi,-0x4(%rbp)
&lt;+11&gt;:	mov    %esi,-0x8(%rbp)
&lt;+14&gt;:	mov    -0x4(%rbp),%edx
&lt;+17&gt;:	mov    -0x8(%rbp),%eax
&lt;+20&gt;:	add    %edx,%eax
&lt;+22&gt;:	mov    %eax,%esi
&lt;+24&gt;:	mov    $0x400610,%edi
&lt;+29&gt;:	mov    $0x0,%eax
&lt;+34&gt;:	callq  0x400400 &lt;printf@plt&gt;
&lt;+39&gt;:	nop
&lt;+40&gt;:	leaveq
&lt;+41&gt;:	retq
</pre>
</td>
</tr>
</table>
</div>

<div class="slide">
<h1>-O0 Optimization Example</h1>
<ul>
	<li>Stack space allocation</li>
	<li>Arguments stored on stack</li>
</ul>
<table>
<tr>
<td>
<pre>
void print_sum(int a, int b) {
	printf("%d\n", a + b);
}

int main(int argc, char **argv) {
	print_sum(5,4);
	return (0);
}
</pre>
<pre>
$ gcc --version
gcc (GCC) 6.2.1 20160916 (Red Hat 6.2.1-2)
$ gcc -Wall -O0 -otest test.c
</pre>
</td>
<td>
<pre>
$ gdb test
(gdb) disassemble print_sum
Dump of assembler code for function print_sum:
&lt;+0&gt;:	push   %rbp
&lt;+1&gt;:	mov    %rsp,%rbp
&lt;+4&gt;:	sub    $0x10,%rsp
&lt;+8&gt;:	<span class="red">mov    %edi,-0x4(%rbp)</span>
&lt;+11&gt;:	<span class="red">mov    %esi,-0x8(%rbp)</span>
&lt;+14&gt;:	<span class="red">mov    -0x4(%rbp),%edx</span>
&lt;+17&gt;:	<span class="red">mov    -0x8(%rbp),%eax</span>
&lt;+20&gt;:	add    %edx,%eax
&lt;+22&gt;:	mov    %eax,%esi
&lt;+24&gt;:	mov    $0x400610,%edi
&lt;+29&gt;:	mov    $0x0,%eax
&lt;+34&gt;:	callq  0x400400 &lt;printf@plt&gt;
&lt;+39&gt;:	nop
&lt;+40&gt;:	leaveq
&lt;+41&gt;:	retq
</pre>
</td>
</tr>
</table>
</div>

<div class="slide">
<h1>-O1 Optimization Example</h1>
<ul>
	<li>&nbsp;</li>
	<li>&nbsp;</li>
	<li>&nbsp;</li>
</ul>
<table>
<tr>
<td>
<pre>
void print_sum(int a, int b) {
	printf("%d\n", a + b);
}

int main(int argc, char **argv) {
	print_sum(5,4);
	return (0);
}
</pre>
<pre>
$ gcc --version
gcc (GCC) 6.2.1 20160916 (Red Hat 6.2.1-2)
$ gcc -Wall -O1 -otest test.c
</pre>
</td>
<td>
<pre>
$ gdb test
(gdb) disassemble main
Dump of assembler code for function main:
&lt;+0&gt;:	sub    $0x8,%rsp
&lt;+4&gt;:	mov    $0x9,%esi
&lt;+9&gt;:	mov    $0x400600,%edi
&lt;+14&gt;:	mov    $0x0,%eax
&lt;+19&gt;:	callq  0x400400 &lt;printf@plt&gt;
&lt;+24&gt;:	mov    $0x0,%eax
&lt;+29&gt;:	add    $0x8,%rsp
&lt;+33&gt;:	retq
</pre>
</td>
</tr>
</table>
</div>

<div class="slide">
<h1>-O1 Optimization Example</h1>
<ul>
	<li>Function print_sum() inlined!</li>
	<li>No stack frame created</li>
	<li>Stack alignment requirement</li>
</ul>
<table>
<tr>
<td>
<pre>
void print_sum(int a, int b) {
	printf("%d\n", a + b);
}

int main(int argc, char **argv) {
	print_sum(5,4);
	return (0);
}
</pre>
<pre>
$ gcc --version
gcc (GCC) 6.2.1 20160916 (Red Hat 6.2.1-2)
$ gcc -Wall -O1 -otest test.c
</pre>
</td>
<td>
<pre>
$ gdb test
(gdb) disassemble main
Dump of assembler code for function main:
&lt;+0&gt;:	<span class="red">sub    $0x8,%rsp</span>
&lt;+4&gt;:	mov    $0x9,%esi
&lt;+9&gt;:	mov    $0x400600,%edi
&lt;+14&gt;:	mov    $0x0,%eax
&lt;+19&gt;:	callq  0x400400 &lt;printf@plt&gt;
&lt;+24&gt;:	mov    $0x0,%eax
&lt;+29&gt;:	add    $0x8,%rsp
&lt;+33&gt;:	retq
</pre>
</td>
</tr>
</table>
</div>

<div class="slide">
<h1>-O1 Optimization Example</h1>
<ul>
	<li>Function print_sum() inlined!</li>
	<li>Breakpoints in print_sum() don't work</li>
	<li>print_sum() is not visible in stack trace</li>
</ul>
<pre>
(gdb) b printf
Breakpoint 1 at 0x400400
(gdb) run
Starting program: /home/ersin/temp/test

Breakpoint 1, __printf (format=0x4005f0 "%d\n") at printf.c:28
28	{
(gdb) bt
#0  __printf (format=0x4005f0 "%d\n") at printf.c:28
#1  0x0000000000400445 in main ()
</pre>
<pre>
$ gdb test
(gdb) disassemble main
Dump of assembler code for function main:
&lt;+0&gt;:	sub    $0x8,%rsp
&lt;+4&gt;:	mov    $0x9,%esi
&lt;+9&gt;:	mov    $0x400600,%edi
&lt;+14&gt;:	mov    $0x0,%eax
&lt;+19&gt;:	callq  0x400400 &lt;printf@plt&gt;
&lt;+24&gt;:	mov    $0x0,%eax
&lt;+29&gt;:	add    $0x8,%rsp
&lt;+33&gt;:	retq
</pre>
</div>

<div class="slide">
<h1>-O2 Optimization Example</h1>
<ul>
	<li>Instruction micro tunning</li>
</ul>
<table>
<tr>
<td>
<pre>
void print_sum(int a, int b) {
	printf("%d\n", a + b);
}

int main(int argc, char **argv) {
	print_sum(5,4);
	return (0);
}
</pre>
<pre>
$ gcc --version
gcc (GCC) 6.2.1 20160916 (Red Hat 6.2.1-2)
$ gcc -Wall -O2 -otest test.c
</pre>
</td>
<td>
<pre>
$ gdb test
(gdb) disassemble main
Dump of assembler code for function main:
&lt;+0&gt;:	sub    $0x8,%rsp
&lt;+4&gt;:	mov    $0x9,%esi
&lt;+9&gt;:	mov    $0x4005f0,%edi
&lt;+14&gt;:	xor    %eax,%eax
&lt;+16&gt;:	callq  0x400400 &lt;printf@plt&gt;
&lt;+21&gt;:	xor    %eax,%eax
&lt;+23&gt;:	add    $0x8,%rsp
&lt;+27&gt;:	retq
</pre>
</td>
</tr>
</table>
</div>

<div class="slide cover">
 <br clear="all" />
 <h1>Other architectures (interesting features)</h1>
</div>

<div class="slide">
<h1>ARM32 CPU Modes</h1>
<ul>
    <li>User &mdash; non-privileged</li>
    <li>FIQ &mdash; fast interrupt handling</li>
    <li>IRQ &mdash; normal interrupt handling</li>
    <li>Supervisor &mdash; OS privileged mode</li>
    <li>Abort &mdash; virtual memory and memory protection</li>
    <li>Undefined &mdash; emulation of co-processors in HW</li>
    <li>System &mdash; privileged mode</li>
</ul>
</div>

<div class="slide">
<h1>ARM32 Register Shadowing</h1>
<table class="border centered">
    <tr>
        <th>usr</th>
        <th>sys</th>
        <th>svc</th>
        <th>abt</th>
        <th>und</th>
        <th>irq</th>
        <th>fiq</th>
    </tr>
    <tr><td colspan="7">R0 &mdash; R7</td></tr>
    <tr>
        <td colspan="6">R8 &mdash; R12</td>
        <td>R8_fiq &mdash; R12_fiq</td>
    </tr>
    <tr>
        <td colspan="2">R13, R14</td>
        <td>R13_svc, R14_svc</td>
        <td>R13_abt, R14_abt</td>
        <td>R13_und, R14_und</td>
        <td>R13_irq, R14_irq</td>
        <td>R13_fiq, R14_fiq</td>
    </tr>
    <tr><td colspan="7">R15</td></tr>
    <tr><td colspan="7">CPSR</td></tr>
    <tr>
        <td colspan="2"></td>
        <td>SPSR_svc</td>
        <td>SPSR_abt</td>
        <td>SPSR_und</td>
        <td>SPSR_irq</td>
        <td>SPSR_fiq</td>
    </tr>
</table>
<ul>
    <li>R13 &mdash; Stack Pointer</li>
    <li>R14 &mdash; Link Register (contains return address)</li>
    <li>R15 &mdash; Program Counter</li>
    <li>C(S)PSR &mdash; Current (Stored) Program Status Register</li>
</ul>
</div>

<div class="slide">
<h1>ARM64</h1>
<ul>
	<li>R0-R30 &mdash; general-purpose registers (with W0-W30 being the lower halves)</li>
    <li>R30 used for <em>link register</em></li>
    <li>R31 &mdash; <em>stack pointer</em> for instructions dealing with stack, <em>zero register</em> for others</em></li>
    <li>4 exception levels (EL0-EL3)</li>
    <ul>
        <li>Each has its own stack pointer, link register, and saved program status register</li>
        <li>No other registers are shadowed</li>
    </ul>
</ul>
</div>

<div class="slide">
<h1>z/Architecture (s390x)</h1>
<ul>
    <li>Used on IBM's mainframe computers</li>
    <li>64-bit addressing (allows for <b>16 exabytes</b> of memory)</li>
    <li>Previous version (System/390) used only 31-bit addressing (2 GiB)</li>
    <ul>
        <li>Programs were able to create additional memory areas of 2 GiB (dataspaces and hiperspaces)</li>
        <li>Expanded storage</li>
        <ul>
            <li>Page-addressable space (originally) separated from the main memory</li>
            <li>Operated via MVPG (Move Page) instructions</li>
            <li>Now discontinued (64-bit addressing is sufficient)</li>
        </ul>
    </ul>
</ul>
</div>

<div class="slide">
<h1>RISC-V</h1>
<ul>
    <li><b>Open-source licensed</b> (i.e. free to use)</li>
    <li>Academically developed (originally started at Berkeley)</li>
    <li>Specification includes support for 128-bit words (reserved for now)</li>
    <li>Wide support across operating systems/software tools</li>
    <ul>
        <li>Linux, FreeBSD, OpenBSD, NetBSD</li>
        <li>GCC, LLVM, QEMU, ...</li>
    </ul>
</ul>
</div>

<div class="slide">
<h1>Branch Delay Slot (MIPS and SPARC)</h1>
<ul>
	<li>One instruction after the current one is <em>always</em> executed</li>
	<li>Even if the preceeding instruction has jumped elsewhere</li>
	<li>This is because the next instruction is already in the CPU pipeline</li>
</ul>
</div>

<div class="slide">
<h1>TLB Miss</h1>
<ul>
	<li><em>TLB</em> - Translation Lookaside Buffer</li>
	<li>A small associative cache used for fast VMA-&gt;PMA translation</li>
	<li>Skylake has ~4KB ITLB, ~4KB DTLB</li>
	<li>Other architectures don't maintain TLB automatically - <em>TLB miss</em> trap.</li>
</ul>
</div>

<div class="slide">
<h1>Unaligned Access Trap</h1>
<ul>
	<li>Some CPUs might trap when access is not naturally / 16 bytes aligned</li>
		<ul>
			<li>ARM, MIPS, SPARC, &hellip;</li>
		</ul>
	<li>Intel CPUs are significantly slower when operating on unaglined data</li>
		<ul>
			<li>Across 64-byte cache line</li>
			<li>Much worse when across page boundary</li>
			<li>Up until Nehalem / Sandy Bridge?</li>
			<li>Still traps on unaligned access using SSE instruction</li>
		</ul>
	<li>
	<li>gcc __attribute__((aligned(16)));</li>
</ul>
</div>

<ul>
<div class="slide cover">
 <div>
 <img src="images/Logo-RedHat-A-White-RGB.png" alt="RH logo" class="cover" />
 <br clear="all" />
 <h1>That's all folks, Thank you!</h1>
 </div>
</div>

</body>
</html>
